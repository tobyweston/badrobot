<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright (c) 2009-2011, bad robot (london) ltd
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->


<document xmlns="http://maven.apache.org/XDOC/2.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

    <properties>
        <title>Thread Counter</title>
        <author>Toby Weston</author>
    </properties>

    <body>

        <section name="Instrumenting Thread Usage">

            <p>
                One area that was identified as an opportunity to explore shared access was around instrumenting thread
                usage within the system. The requirement being around understanding the cumulative number of threads created
                and the currently active threads (threads started but not yet terminated).
            </p>

            <subsection name="Shared Infrastructure">
                <p>
                    The ultimate goal was to create alternative implementations of something that can be used to
                    instrument thread usage within the system, one pessimistic / lock based implementation and an alternative
                    optimistic implementation. It makes sense if these competing implementations follow a similar
                    approach so that they can be swapped easily for comparison.
                </p>
                <p>
                    The role of collecting or processing this information can be seen in terms of an
                    <i>observer</i>, for example,
                </p>
<source>
public interface ThreadObserver {
    void threadCreated();
    void threadStarted();
    void threadTerminated();
}
</source>
            <p>
                Java's <code>ThreadFactory</code> is a natural place to make observations about thread activity. All that
                would be required is for the application to be wired up to use the following thread factory and we can
                start our instrumentation.
            </p>
<source>
public class ObservableThreadFactory implements ThreadFactory {

    private final ThreadObserver observer;

    public ObservableThreadFactory(ThreadObserver observer) {
        this.observer = observer;
    }

    @Override
    public Thread newThread(final Runnable runnable) {
        Thread thread = new Thread(new Runnable() {
            public void run() {
                try {
                    <b>observer.threadStarted();</b>
                    runnable.run();
                } finally {
                    <b>observer.threadTerminated();</b>
                }
            }
        });
        <b>observer.threadCreated();</b>
        return thread;
    }
}
</source>


            </subsection>

            <subsection name="Pessimistic / Lock Based Synchronisation">
                <h4>Basic Implementation</h4>
                <p>
                    A naive implementation of the <code>ThreadCounter</code> might look like this
                </p>
<source>
public class ThreadCounter implements ThreadFactoryObserver {

    private long activeThreads;
    private long createdThreads;

    @Override
    public void threadCreated() {
        createdThreads++;
    }

    @Override
    public void threadStarted() {
        activeThreads++;
    }

    @Override
    public void threadTerminated() {
        activeThreads--;
    }

    @Override
    public long getActiveCount() {
        return activeThreads;
    }

    @Override
    public long getCreatedCount() {
        return createdThreads;
    }

    @Override
    public void reset() {
        activeThreads = 0;
        createdThreads = 0;
    }
}
</source>
            </subsection>
            <p>
                The basic test below shows the implementation to be correct (at least in a non-concurrent context).
            </p>
<source>
public class ThreadCounterTest {

    private final ThreadCounter counter = new ThreadCounter();

    @Test
    public void shouldInitialiseCounts() {
        assertThat(counter.getActiveCount(), is(0L));
        assertThat(counter.getCreatedCount(), is(0L));
    }

    @Test
    public void shouldIncrementActiveCount() {
        incrementActiveThreadsBy(3);
        assertThat(counter.getActiveCount(), is(3L));
    }

    @Test
    public void shouldDecrementActiveThreadCount() {
        incrementActiveThreadsBy(5);
        assertThat(counter.getActiveCount(), is(5L));
        decrementActiveThreadsBy(5);
        assertThat(counter.getActiveCount(), is(0L));
    }

    @Test
    public void shouldResetCounts() {
        incrementActiveThreadsBy(8);
        incrementThreadsBy(5);
        counter.reset();
        assertThat(counter.getActiveCount(), is(0L));
        assertThat(counter.getCreatedCount(), is(0L));
    }

    private void incrementActiveThreadsBy(int amount) {
        for (int i = 0; i &lt; amount; i++)
            counter.threadStarted();
    }

    private void decrementActiveThreadsBy(int amount)  {
        for (int i = 0; i &lt; amount; i++)
            counter.threadTerminated();
    }

    private void incrementThreadsBy(int amount)  {
        for (int i = 0; i &lt; amount; i++)
            counter.threadCreated();
    }
}
</source>
        <h4>Testing Thread Safety</h4>
        <p>
            The next test shows that it isn't correct from a concurrent context. Here, the
            <a href="http://code.google.com/p/tempus-fugit/wiki/Documentation?tm=6">tempus-fugit</a> micro-library
            is used to run each test method repeatedly over several threads. Specifically, each of the test methods are
            run one hundred times (thanks to the <code>RepeatingRule</code> rule) in fifty threads
            (thanks to the <code>ConcurrentRule</code> rule along with the <code>count</code> variable).
            To kick this off for each test method at the <i>same time</i>, the <code>ConcurrentTestRunner</code> is used.
            Otherwise, each of the test methods will run in their own threads, repeatedly but in sequence (ie,
            <code>notifyThreadStarted</code> would run, then <code>notifyThreadTerminated</code> and so on). Adding
            the <code>@RunWith</code> means that each test method is kicked off in its own thread at roughly the same time.
        </p>
<source>
@RunWith(<b>ConcurrentTestRunner.class</b>)
public class ThreadCounterIntegrationTest {

    private static final ThreadCounter counter = new ThreadCounter();

    @Rule public <b>ConcurrentRule</b> concurrent = new ConcurrentRule();
    @Rule public <b>RepeatingRule</b> repeating = new RepeatingRule();

    @Test
    @Repeating
    @Concurrent(count = 50)
    public void notifyThreadStarted() {
        counter.threadStarted();
        Introduce.jitter();
    }

    @Test
    @Repeating
    @Concurrent(count = 10)
    public void notifyThreadTerminated() {
        counter.threadTerminated();
        Introduce.jitter();
    }

    @Test
    @Repeating
    @Concurrent(count = 50)
    public void notifyThreadCreated() {
        counter.threadCreated();
        Introduce.jitter();
    }

    @AfterClass
    public static void verifyCounter() {
        assertThat(activeCount.get(), is(4000L));
        assertThat(createdCount.get(), is(5000L));
    }
}
</source>
            <h4>Testing Invariants</h4>
            <p>
                The above test is designed to load the class under test so heavily that it is <i>reasonably likely</i> to
                fail the assertions (in <code>verifyCounter()</code>). It doesn't however test the invariant around the
                <code>reset</code> method. It could be argued that if <code>reset</code> is called, it should reset both
                <code>activeThreads</code> and <code>createdThreads</code> atomically. That is to say, no additional updates
                should be allowed to either variable until both have been set to zero.
            </p>
            <p>
                Testing the invariant directly proved too difficult to do, it was just too hard to simulate the race
                condition between resetting and setting multiple variables. However, as well see, the natural progression
                of the implementation lead to an alternative strategy which ensures the invariant in maintained.
            </p>

            <subsection name="Optimistic / Software Transaction Memory">
            </subsection>

        </section>

    </body>

</document>