<?xml version="1.0" encoding="UTF-8"?>

<!--
  ~ Copyright (c) 2009-2011, bad robot (london) ltd
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<!--
Fool Maven's validator:
(see http://jira.codehaus.org/browse/MSITE-440)
<document blah="true">
</document>
-->
<document xmlns="http://maven.apache.org/XDOC/2.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

    <properties>
        <title>Contention Monitoring</title>
        <author>Toby Weston</author>
    </properties>

    <body>

        <section name="Contention Monitoring">

            <p>
                In making comparisons between the implementations, before making conclusions, it may be useful to
                understand any contention between competing threads on resources. For us, we're interested in contention
                when access to shared memory; when two or more threads simultaneously attempt to access some shared
                memory and a guard rejects access.
            </p>
            <p>
                For the purposes of this discussion, we can define contention as follows.
            </p>
            <ol>
                <li>
                    <p>
                        <b>Pessimistic (<code>synchronized</code>) </b> - the number of requests blocked whilst attempting
                        to acquire an object monitor.
                    </p>
                </li>
                <li>
                    <p>
                        <b>Optimistic (<code>Lock</code>s) </b> - the number of requests made to wait whilst attempting
                        to acquire a lock.
                    </p>
                </li>
                <li>
                    <p>
                        <b>Optimistic (Software Transactional Memory) </b> - the number of aborted atomic updates (this
                        assumes an abort is the result of an attempt to access a transactional reference which has already
                        been accessed and not some other runtime exception).

                    </p>
                </li>
            </ol>
            <p>
                It may also be useful to represent the contention as a ratio against the number of successful requests.
                For example, the number of blocked requests divided by the total number of requests. Comparing contention
                ratios should be done over the same number of requests to be fair.
            </p>
            <p>
                See <a href="appendix_A.html">Appendix A</a> for some additional background.
            </p>

            <subsection name="Contention in Pessimistic Concurrency Control">
                <p>
                    To begin with we're interested in recording contention caused by the waiting on monitor acquisition.
                    We can use the Java class <code>ThreadInfo</code> to get information about a particular thread
                    including the block count (the number of times the thread has been in the <code>BLOCKED</code> state
                    and total elapsed time a thread has been blocked (again, the total time spent in the <code>BLOCKED</code>
                    state). The state transition to <code>BLOCKED</code> is only possible when a thread is waiting to
                    acquire (or re-acquire) an object's monitor.
                </p>
                <p>
                    Unfortunately, the <code>ThreadInfo</code> class doesn't distinguish between the
                    specific monitor a thread is blocked waiting to acquire but we can make some assuptions and provide
                    an approximation using the following code.
                </p>
                <source>
public class ThreadContentionRatio {

    private final Counter count = new AtomicLongCounter();
    private final Map&lt;Long, Long&gt; blocked = new ConcurrentHashMap&lt;Long, Long&gt;();
    private final ThreadMXBean jvm;

    public ThreadContentionRatio(Factory&lt;ThreadMXBean&gt; factory) {
        jvm = factory.create();
    }

    public void sample() {
        count.increment();
        blocked.put(currentThread().getId(), getBlockedCount(currentThread()));
    }

    public Double get() {
        double ratio = 0;
        for (Long blocked : this.blocked.values())
            ratio += (double) blocked / (double) count.get();
        return ratio;
    }

    private long getBlockedCount(Thread thread) {
        return jvm.getThreadInfo(thread.getId()).getBlockedCount();
    }

}
                </source>
                <p>
                    Here, we assume that client will "sample" contention at appropriate times which is basically during
                    load. We also brush over the fact that the instrumentation itself may influence the results. We use
                    an <code>AtomicLongCounter</code> and <code>ConcurrentHashMap</code> as they both offer optimistic
                    thread safety (with the implication being that they are fast). We also defer maintaining the
                    consistency of updating <code>count</code> and <code>blocked</code> together (for example, by using a
                    <code>Guard</code>) for the same reason; namely we're favouring performance over accuracy. We use a
                    factory to create the <code>ThreadMXBean</code> in order to be able to write unit style tests without
                    using real JVM thread metadata.
                </p>
                <p>
                    As we are interested in monitoring contention around locks, we can conveniently use the
                    <code>ThreadContentionRation</code> class from a custom <code>Guard</code> implementation.
                    The guard is our abstraction for protecting resources and we're interested in understanding contention
                    at this point. As we're also interested in the total number of requests, we can employ the
                    <code>Throughput</code> class defined previously.
                </p>
                <source>
public class ContentionMonitoringGuard implements Guard, ContentionMonitoringGuardMBean {

    private final ThreadContentionRatio contention = new ThreadContentionRatio(new JmxThreadMxBean());

    @Override
    public &lt;R, E extends Exception&gt; R execute(Callable&lt;R, E&gt; callable) throws E {
        <b>synchronized</b> (this) {
            RequestObserver.Request request = throughput.started();
            try {
                return callable.call();
            } finally {
                request.finished();
                <b>contention.sample();</b>
            }
        }
    }

    @Override
    public Boolean guarding() {
        return true;
    }

    @Override
    public Double getContentionRatio() {
        return contention.get();
    }

    @Override
    public Double getRequestsPerSecond() {
        return throughput.getRequestsPerSecond();
    }

    @Override
    public Long getTotalRequests() {
        return throughput.getTotalRequests();
    }
}
                </source>

                <p>
                    An instance of this guard will be used to protect some shared resource and as such will sample the
                    current thread's block count just before releasing it's monitor. A thread which manages to execute the
                    guarded section (the call to <code>callable.call()</code>) without being blocked will record
                    no contention. If however, whilst that thread is executing the guarded section, another attempts to
                    do the same, it will block until the first has released the monitor. In this case, the second
                    thread will record a blocked attempt when executing the <code>contention.sample()</code> method. A
                    thread dump showing the blocking behaviour is shown below.
                </p>
<source>
Thread Thread-0@9: (state = RUNNABLE)
 ...
 - bad.robot.pessimistic.ContentionMonitoringGuardTest$1.call(ContentionMonitoringGuardTest.java:14)
 - bad.robot.pessimistic.ContentionMonitoringGuard.execute(ContentionMonitoringGuard.java:36)
 - bad.robot.pessimistic.ContentionMonitoringGuardTest$3.run(ContentionMonitoringGuardTest.java:36)
 - java.lang.Thread.run(Thread.java:722)

Thread Thread-1@10: (state = BLOCKED)
 - bad.robot.pessimistic.ContentionMonitoringGuard.execute(ContentionMonitoringGuard.java:34)
 - bad.robot.pessimistic.ContentionMonitoringGuardTest$3.run(ContentionMonitoringGuardTest.java:36)
 - java.lang.Thread.run(Thread.java:722)
</source>

            <p>
                <code>Thread-0</code> acquired the guard's monitoring and is executing (it's in the <code>RUNNABLE</code>
                state) whilst <code>Thread-1</code> is <code>BLOCKED</code> at the <code>execute</code> call.
                When <code>Thread-1</code> finally continues the <code>ContentionMonitoringGuard</code> would indicate a
                contention ratio of 0.5. Half the requests were contended.
            </p>
            </subsection>

            <subsection name="Contention in Software Transaction Memory">

            </subsection>

        </section>

    </body>

</document>